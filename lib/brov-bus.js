// Generated by CoffeeScript 1.10.0

/*
Abstraction layer between the Publisher using the bus and the underlying library.

@author Jean-Laurent Picard <jean.laurent.picard at gmail>
 */

(function() {
  var BrovBus, Publisher;

  Publisher = (function() {
    var get;

    function Publisher() {}

    get = function(props) {
      var getter, name, results;
      results = [];
      for (name in props) {
        getter = props[name];
        results.push(Publisher.prototype.__defineGetter__(name, getter));
      }
      return results;
    };

    Publisher.prototype._publisher = {};

    Publisher.prototype._messagingLibrary = {};


    /*
    Takes the intended message and corresponding filter, and sends then to the bus using the selected underlying library.
    
    Defined by {BrovBus.getPublisher}
    
    @abstract 
    @param filter [string] Filter sent together with the message
    @param message [String] The message itself
     */

    Publisher.prototype._send = function(filter, message) {};

    get({
      send: function() {
        return this._send;
      }
    });

    return Publisher;

  })();


  /*
  The class create a bus using an underlying library (zmq currently supported, 
  events is next), and expose methods to  bind publishers / subscribers to that
  bus. It also defines a standard {Publisher} class, that offer an abstraction layer
  between publishers and the bus' underlying librairy, by exposing a standard 
  send(class, content) method. Different underlying librairy will expose different
  {Publisher} class.
  
  @author Jean-Laurent Picard <jean.laurent.picard at gmail>
   */

  module.exports = BrovBus = (function() {
    BrovBus.prototype.busType = '';

    BrovBus.prototype.busName = '';


    /*
    @example Create a bus using zmq as the underlying librairy
      bus = new BrovBus('zmq', 'ZmqBus', {zmqUri: 'inprocess://communicationBus'})
     
    @param busType [String] Underlying librariy. Only 'zmq' is valid. 'zmq' by default.
    @param busName [String] May be used in the logs. 'BrovBus_defaultName' by default.
    @param options [Object] Different busType may take different options.
    @option options zmqUri [String] uri used by zmq's socket.bind(uri, callback) function (eg. "inprocess://name",
      "tcp://127.0.0.1:5000", "icp:///tmp/feed", etc.)
     */

    function BrovBus(busType, busName, options) {
      this.busType = busType != null ? busType : 'zmq';
      this.busName = busName != null ? busName : 'BrovBus_defaultName';
      if (options == null) {
        options = {};
      }
      console.log("Instancing new Brov-Bus (" + this.busName + ")");
      console.log("...Selecting bus type");
      if (options != null) {
        console.log("......Options provided: " + (JSON.stringify(options)));
      }
      switch (this.busType) {
        case 'zmq':
          this._messagingLibrary = require('zmq');
          this.zmqUri = "inproc://bluerovqueue";
          if (options["zmqUri"] != null) {
            this.zmqUri = options["zmqUri"];
          }
          console.log("......(zmqUri set to " + this.zmqUri + ")");
          break;
        case 'events':
          this._messagingLibrary = require('events');
          break;
        default:
          throw new Error('brov-bus.constructor: unknown bus type (#{@busType})');
      }
      console.log("......" + this.busType + " type bus is now setup");
      return;
    }


    /*
    @overload registerSubscriber(callback, filters)
      Binds a callback function to a subscriber on the bus. The callback is called only if the message's filter 
      matches one of those provided in an Array as argument.
      @param callback [Function] callback(Error, filter[String], message[String])
      @param filters [Array<String>] filter eg. ["FILTER1", "FILTER2", ...]
    
    @overload registerSubscriber(callback, filter)
      Binds a callback function to a subscriber on the bus. The callback is called only if the message's filter 
      matches the filter provided as argument.
      @param callback [Function] callback(Error, filter[String], message[String])
      @param filter [String] filter eg. "FILTER3". NB: if set to undefined: the Subscriber will receive all messages sent to the bus
     */

    BrovBus.prototype.registerSubscriber = function(callback, filters) {
      var filter, i, len, subscriber, zmqcallback;
      if (callback == null) {
        throw new Error("registerSubscriber: callback argument is missing");
      }
      console.log("Registering a new subscriber on " + this.busName + ", filters set to " + (JSON.stringify(filters)));
      switch (this.busType) {
        case 'zmq':
          subscriber = this._messagingLibrary.socket("sub");
          subscriber.connect(this.zmqUri);
          if (filters == null) {
            subscriber.subscribe('');
          } else {
            for (i = 0, len = filters.length; i < len; i++) {
              filter = filters[i];
              subscriber.subscribe(filter);
            }
          }
          zmqcallback = function(msg) {
            var err, message, splittedMsg;
            err = null;
            splittedMsg = msg.toString().split(' ');
            if (splittedMsg.length < 2) {
              err = new Error("(BrovBus.registerSubscriber - zmqcallback) - incorrect zmq message (no space or empty)");
            }
            filter = splittedMsg[0];
            message = splittedMsg.slice(1).join(' ');
            return callback(err, filter, message);
          };
          subscriber.on('message', zmqcallback);
          break;
        case 'events':
          subscriber = this._messagingLibrary;
          break;
        default:
          throw new Error("Internal error");
      }
    };


    /*
    Returns a Publisher object that exposes the method send(filter, message). The send method will
    be overchared depending on the selected underlying messaging librairy (see [BrovBus] class)
    
    @return [Publisher] Class offering an abstraction layer to the underlying messaging librairy
     */

    BrovBus.prototype.getPublisher = function() {
      var publisher, zmqPub;
      publisher = new Publisher;
      switch (this.busType) {
        case 'zmq':
          zmqPub = this._messagingLibrary.socket("pub");
          zmqPub.bind(this.zmqUri, function() {
            if (typeof err !== "undefined" && err !== null) {
              throw err;
            }
          });
          publisher._publisher = zmqPub;
          publisher._send = function(filter, message) {
            return this._publisher.send(filter + " " + message);
          };
          break;
        case 'events':
          throw new Error("registerSubscriber / events - NOT IMPLEMENTED");
          break;
        default:
          throw new Error("Unknown bus type (" + this.busType + ")");
      }
      return publisher;
    };

    return BrovBus;

  })();

}).call(this);
